/*
 * Copyright (c) 2015 by Greg Reimer <gregreimer@gmail.com>
 * All Rights Reserved.
 */

var stream = require('stream')
  , util = require('util')
  , EventEmitter = require('events').EventEmitter
  , co = require('co')
  , wait = require('jtg/wait')
  , context = { delay: wait }

// -----------------------------------------------------

/*
 * This is an implementation of a transform stream
 * that uses a generator to handle its I/O.
 */

function Transform(opts, genFn) {
  stream.Transform.call(this, opts);
  this._incomingValues = iterateStream(this);
  this._receiving = unresolved();
  var self = this;
  function input() {
    return self._incomingValues.next().value;
  }
  input.ended = function(){
    return !!this._ended;
  };
  function output(data) {
    return self._receiving.then(function() {
      if (!self.push(data)) {
        self._receiving = unresolved();
      }
    });
  }
  co(genFn, context, input, output)
  .then(function() { self.push(null); })
  .catch(function(err) { self.emit('error', err); })
}

Transform.prototype._transform = function(chunk, enc, callback) {
  this.emit('_transformCalled', chunk, enc, callback);
  this._receiving.resolve();
};

Transform.prototype._flush = function(callback) {
  this._ended = true;
  callback();
};

util.inherits(Transform, stream.Transform);

// -----------------------------------------------------

/*
 * This creates an unresolved promise and
 * sticks its resolve function on the outside
 * of it so that someone else can resolve it.
 * There's probably a better way to do this.
 */

function unresolved() {
  var resolver, prom = new Promise(function(resolve){
    resolver = resolve;
  });
  prom.resolve = resolver;
  return prom;
}

// -----------------------------------------------------

/*
 * This converts a stream into an iterable of promises.
 * Every time you call next() it returns a promise for
 * the next thing that was or will be written to that
 * stream via the internal call to _transform().
 */

function* iterateStream(stream) {
  var promIdx = 0
    , emitIdx = 0
    , numEmitter = new EventEmitter()
    , cache = Map()

  /*
  P = emitIdx - promIdx
  P > 0: data is being written to us faster that we're consuming
  P < 0: we're consuming faster than data is being written to us
  */

  stream.on('_transformCalled', function(chunk, enc, callback) {
    if (emitIdx >= promIdx) {
      cache.set(emitIdx, chunk);
      // TODO: figure out how to do this better
      setTimeout(callback, emitIdx - promIdx);
    } else {
      numEmitter.emit(emitIdx, chunk);
      callback();
    }
    emitIdx++;
  });
  while (true) {
    if (cache.has(promIdx)) {
      yield new Promise(function(resolve) {
        var thing = cache.get(promIdx);
        cache.delete(promIdx);
        resolve(thing);
      });
    } else if (stream._ended) {
      yield new Promise(function(resolve, reject) {
        reject(new Error('the stream has ended'));
      });
    } else {
      yield new Promise(function(resolve) {
        numEmitter.once(promIdx, resolve);
      });
    }
    promIdx++;
  }
}
