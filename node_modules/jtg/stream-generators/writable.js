var stream = require('stream')
  , util = require('util')
  , EventEmitter = require('events').EventEmitter
  , co = require('co')
  , wait = require('jtg/wait')
  , context = { delay: wait }

/*
 * _write() being called means there's data available.
 * calling the callback passed to _write() means we've accepted that data.
 */

function Writable(opts, genFn) {
  stream.Writable.call(this, opts);
  this._writeIterator = iterateEmitter(this, '_writeCalled');
  var self = this
    , isDone = false
  this.on('end', function() {
    isDone = true;
  });
  function input() {
    return self._writeIterator.next().value;
  }
  input.hasNext = function() {
    return isDone;
  };
  co(genFn, context, input)
  .then(function() {
    if (typeof self._callThisWhenDone === 'function') {
      self._callThisWhenDone();
      delete self._callThisWhenDone;
    }
  })
  .catch(function(err) {
    self.emit('error', err);
  });
}

util.inherits(Writable, stream.Writable);

Writable.prototype._write = function(chunk, enc, done) {
  this.emit('_writeCalled', chunk);
};







function* iterateEmitter(emitter, eventName) {
  var promIdx = 0
    , emitIdx = 0
    , numEmitter = new EventEmitter()
    , cache = Map()
  emitter.on(eventName, function(thing) {
    if (emitIdx >= promIdx) {
      cache.set(emitIdx, thing);
    } else {
      numEmitter.emit(emitIdx, thing);
    }
    emitIdx++;
  });
  while (true) {
    if (cache.has(promIdx)) {
      yield new Promise(function(resolve) {
        var thing = cache.get(promIdx);
        cache.delete(promIdx);
        resolve(thing);
      });
    } else {
      yield new Promise(function(resolve) {
        numEmitter.once(promIdx, resolve);
      });
    }
    promIdx++;
  }
}






