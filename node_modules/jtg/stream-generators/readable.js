var stream = require('stream')
  , util = require('util')
  , co = require('co')
  , wait = require('jtg/wait')
  , context = { delay: wait }

/*
 * NOTE:
 * _read() being called is a signal to start calling push()
 * push() returning false is a signal to stop calling push()
 */

function createReadProm(stream) {
  return new Promise(function(resolve){
    stream._resolveReadProm = resolve;
  });
}

function Readable(opts, genFn) {
  stream.Readable.call(this, opts);
  stream._readProm = createReadProm(this);
  var self = this;
  co(genFn, context, function(chunk) {
    return self._readProm.then(function(/*size*/) {
      // how to deal with size?
      if (!self.push(chunk)) {
        createReadProm(self);
      }
    });
  })
  .then(function() {
    self.push(null);
  })
  .catch(function(err) {
    self.emit('error', err);
  });
}

util.inherits(Readable, stream.Readable);

Readable.prototype._read = function(size) {
  this._resolveReadProm(size);
};


