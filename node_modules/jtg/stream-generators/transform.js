var stream = require('stream')
  , util = require('util')
  , EventEmitter = require('events').EventEmitter
  , co = require('co')
  , wait = require('jtg/wait')
  , context = { delay: wait }

// -----------------------------------------------------

function Transform(opts, genFn) {
  stream.Transform.call(this, opts);
  this._incomingValues = iterateStream(this);
  this._receiving = unresolved();
  var self = this;
  function input() {
    return self._incomingValues.next().value;
  }
  input.ended = function(){
    return !!this._ended;
  };
  function output(data) {
    return self._receiving.then(function() {
      if (!self.push(data)) {
        self._receiving = unresolved();
      }
    });
  }
  co(genFn, context, input, output)
}

Transform.prototype._transform = function(chunk, enc, callback) {
  this.emit('_transformCalled', chunk, enc, callback);
  this._receiving.resolve();
};

Transform.prototype._flush = function(callback) {
  this._ended = true;
  callback();
};

util.inherits(Transform, stream.Transform);

// -----------------------------------------------------

function unresolved() {
  var resolver, prom = new Promise(function(resolve){
    resolver = resolve;
  });
  prom.resolve = resolver;
  return prom;
}

function* iterateStream(stream) {
  var promIdx = 0
    , emitIdx = 0
    , numEmitter = new EventEmitter()
    , cache = Map()
  stream.on('_transformCalled', function(chunk, enc, callback) {
    if (emitIdx >= promIdx) {
      cache.set(emitIdx, chunk);
      setTimeout(callback, emitIdx - promIdx);
    } else {
      numEmitter.emit(emitIdx, chunk);
      callback();
    }
    emitIdx++;
  });
  while (true) {
    if (cache.has(promIdx)) {
      yield new Promise(function(resolve) {
        var thing = cache.get(promIdx);
        cache.delete(promIdx);
        resolve(thing);
      });
    } else if (stream._ended) {
      yield new Promise(function(resolve, reject) {
        reject(new Error('the stream has ended'));
      });
    } else {
      yield new Promise(function(resolve) {
        numEmitter.once(promIdx, resolve);
      });
    }
    promIdx++;
  }
}
