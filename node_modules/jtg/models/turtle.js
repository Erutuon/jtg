/*
 * Copyright (c) 2015 by Greg Reimer <gregreimer@gmail.com>
 * All Rights Reserved.
 */

var Pen = require('jtg/models/pen')
  , Field = require('jtg/models/field')
  , Grid = require('jtg/models/grid')
  , random = require('jtg/random')
  , co = require('co')
  , wait = require('jtg/wait')

var Turtle = module.exports = class {

  constructor(opts) {
    this._drawCanvas = opts.drawCanvas
    this._fieldCanvas = opts.fieldCanvas
    this._turtleCanvas = opts.turtleCanvas
    this._drawContext = this._drawCanvas.getContext('2d')
    this._fieldContext = this._fieldCanvas.getContext('2d')
    this._turtleContext = this._turtleCanvas.getContext('2d')

    this._ratio = window.devicePixelRatio
    this._grid = new Grid(this._drawCanvas.width, this._drawCanvas.height, this._ratio)

    this._state = {
      x: 0,
      y: 0,
      heading: 0
    }
    this.pen = new Pen(this)
    this.field = new Field(this)
    this.rand = random
    this._locateCursor()
  }

  // -----------------------------------

  _copyPropsTo(other) {
    other._turtle = this
    other._drawCanvas = this._drawCanvas
    other._fieldCanvas = this._fieldCanvas
    other._turtleCanvas = this._turtleCanvas
    other._drawContext = this._drawContext
    other._fieldContext = this._fieldContext
    other._turtleContext = this._turtleContext
    other._grid = this._grid
  }

  _locateCursor() {
    var state = this._state
      , grid = this._grid
      , ctx = this._turtleContext
      , x = state.x
      , y = state.y
    ctx.clearRect(0, 0, grid.width, grid.height)
    // TODO: make a triangle instead of a circle
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.2)'
    ctx.arc(this._grid.x(x), this._grid.y(y), this._grid.scale(5), 0, 2 * Math.PI, true)
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = '#fff'
    ctx.arc(this._grid.x(x), this._grid.y(y), this._grid.scale(4), 0, 2 * Math.PI, true)
    ctx.fill();
  }

  _line(x2, y2) {
    var state = this._state
      , ctx = this._drawContext
      , x1 = state.x
      , y1 = state.y
    ctx.beginPath()
    ctx.strokeStyle = this.pen.color()
    ctx.lineWidth = this._grid.scale(this.pen.weight())
    ctx.moveTo(this._grid.x(x1), this._grid.y(y1))
    ctx.lineTo(this._grid.x(x2), this._grid.y(y2))
    if (this.pen.isDown()) {
      ctx.stroke()
    }
    state.x = x2
    state.y = y2
    this._locateCursor()
  }

  // -----------------------------------

  fd(len) {
    return () => {
      var state = this._state
        , x = state.x + (Math.sin((state.heading / 180) * Math.PI) * len)
        , y = state.y + (Math.cos((state.heading / 180) * Math.PI) * len)
      this._line(x, y)
    }
  }

  bk(len) {
    return this.fd(-len)
  }

  home() {
    return () => {
      var state = this._state
      state.x = 0
      state.y = 0
      state.heading = 0
      this._locateCursor()
    }
  }

  circ(radius) {
    return () => {
      var state = this._state
        , ctx = this._drawContext
        , x = state.x
        , y = state.y
      ctx.beginPath();
      ctx.lineWidth = this._grid.scale(this.pen.weight())
      ctx.strokeStyle = this.pen.color()
      ctx.arc(this._grid.x(x), this._grid.y(y), this._grid.scale(radius), 0, 2 * Math.PI, true)
      ctx.stroke();
    }
  }

  disc(radius) {
    return () => {
      var state = this._state
        , ctx = this._drawContext
        , x = state.x
        , y = state.y
      ctx.beginPath();
      ctx.fillStyle = this.pen.color()
      ctx.arc(this._grid.x(x), this._grid.y(y), this._grid.scale(radius), 0, 2 * Math.PI, true)
      ctx.fill();
    }
  }

  xy(x, y) {
    if (arguments.length === 0) {
      return { x: this._state.x, y: this._state.y }
    } else {
      return () => this._line(x, y)
    }
  }

  x(x) {
    if (arguments.length === 0) {
      return this._state.x
    } else {
      return () => this._line(x, this._state.y)
    }
  }

  y(y) {
    if (arguments.length === 0) {
      return this._state.y
    } else {
      return () => this._line(this._state.x, y)
    }
  }

  rt(deg) {
    return () => {
      var state = this._state
        , oldHeading = state.heading
        , newHeading = oldHeading + deg
      while (newHeading < 0) {
        newHeading += 360
      }
      while (newHeading > 360) {
        newHeading -= 360
      }
      state.heading = newHeading
      this._locateCursor()
      return true
    }
  }

  lt(deg) {
    return this.rt(-deg)
  }

  face(x, y) {
    return () => {
      var state = this._state
        , headingRad = Math.atan2(x - state.x, y - state.y)
      state.heading = headingRad * (180/Math.PI)
      this._locateCursor()
      return true
    }
  }

  away(x, y) {
    return () => {
      var state = this._state
        , headingRad = Math.atan2(x - state.x, y - state.y) + Math.PI
      state.heading = headingRad * (180/Math.PI)
      this._locateCursor()
      return true
    }
  }

  heading(deg) {
    if (arguments.length === 0) {
      return this._state.heading
    } else {
      return () => {
        this._state.heading = deg
        this._locateCursor()
        return true
      }
    }
  }

  erase() {
    let ctx = this._drawContext
      , grid = this._grid
    return () => ctx.clearRect(0, 0, grid.width, grid.height)
  }

  oob() {
    var grid = this._grid
      , x = this.x()
      , y = this.y()
    if (grid.x(x) < 0) return true
    if (grid.x(x) > grid.width) return true
    if (grid.y(y) < 0) return true
    if (grid.y(y) > grid.height) return true
    return false
  }
}

var fps = Math.round(1000 / 60) // frames per second

Turtle.run = (genFn, acceleration) => {
  acceleration = acceleration || 1
  co(function *() {
    var i = 0
    for (var command of genFn()) {
      var isFast = command()
      if (!isFast) i++
      if (i % acceleration === 0 && !isFast) {
        yield wait(fps)
      }
    }
  })
  .then(() => {
    console.log('Finished without error.')
  })
  .catch((ex) => {
    console.error(`Error: ${ex.message}`)
  })
}

