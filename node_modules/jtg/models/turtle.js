/*
 * Copyright (c) 2015 by Greg Reimer <gregreimer@gmail.com>
 * All Rights Reserved.
 */

var Pen = require('jtg/models/pen')
  , Field = require('jtg/models/field')
  , Sequencer = require('jtg/models/sequencer')
  , Grid = require('jtg/models/grid')
  , random = require('jtg/random')

module.exports = class {

  constructor(opts) {
    this._sequencer = new Sequencer()
    this._drawCanvas = opts.drawCanvas
    this._fieldCanvas = opts.fieldCanvas
    this._turtleCanvas = opts.turtleCanvas
    this._drawContext = this._drawCanvas.getContext('2d')
    this._fieldContext = this._fieldCanvas.getContext('2d')
    this._turtleContext = this._turtleCanvas.getContext('2d')

    this._ratio = window.devicePixelRatio
    this._rescaleCanvas(this._drawCanvas, this._ratio)
    this._rescaleCanvas(this._fieldCanvas, this._ratio)
    this._rescaleCanvas(this._turtleCanvas, this._ratio)
    this._grid = new Grid(this._drawCanvas.width, this._drawCanvas.height, this._ratio)

    this._state = {
      x: 0,
      y: 0,
      heading: 0
    }
    this.pen = new Pen(this)
    this.field = new Field(this)
    this.rand = random
    this._locateCursor()
  }

  // -----------------------------------

  _rescaleCanvas(canvas, ratio) {
    var width = canvas.width
      , height = canvas.height
    canvas.width = width * ratio
    canvas.height = height * ratio
    canvas.style.width = width + 'px'
    canvas.style.height = height + 'px'
  }

  _copyPropsTo(other) {
    other._turtle = this
    other._sequencer = this._sequencer
    other._drawCanvas = this._drawCanvas
    other._fieldCanvas = this._fieldCanvas
    other._turtleCanvas = this._turtleCanvas
    other._drawContext = this._drawContext
    other._fieldContext = this._fieldContext
    other._turtleContext = this._turtleContext
    other._grid = this._grid
  }

  _locateCursor() {
    var state = this._state
      , grid = this._grid
      , ctx = this._turtleContext
      , x = state.x
      , y = state.y
    ctx.clearRect(0, 0, grid.width, grid.height)
    // TODO: make a triangle instead of a circle
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.2)'
    ctx.arc(this._grid.x(x), this._grid.y(y), this._grid.scale(5), 0, 2 * Math.PI, true)
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = '#fff'
    ctx.arc(this._grid.x(x), this._grid.y(y), this._grid.scale(4), 0, 2 * Math.PI, true)
    ctx.fill();
  }

  _line(x2, y2) {
    var state = this._state
      , ctx = this._drawContext
      , x1 = state.x
      , y1 = state.y
    ctx.beginPath()
    ctx.strokeStyle = this.pen.color()
    ctx.lineWidth = this._grid.scale(this.pen.weight())
    ctx.moveTo(this._grid.x(x1), this._grid.y(y1))
    ctx.lineTo(this._grid.x(x2), this._grid.y(y2))
    if (this.pen.isDown()) {
      ctx.stroke()
    }
    state.x = x2
    state.y = y2
    this._locateCursor()
  }

  // -----------------------------------
  
  fd(len) {
    return this._sequencer.run(function() {
      var state = this._state
        , x = state.x + (Math.sin((state.heading / 180) * Math.PI) * len)
        , y = state.y + (Math.cos((state.heading / 180) * Math.PI) * len)
      this._line(x, y)
    }, this)
  }
  
  bk(len) {
    return this.fd(-len)
  }
  
  home() {
    return this._sequencer.run(function() {
      var state = this._state
      state.x = 0
      state.y = 0
      state.heading = 0
      this._locateCursor()
    }, this)
  }
  
  circ(radius) {
    return this._sequencer.run(function() {
      var state = this._state
        , ctx = this._drawContext
        , x = state.x
        , y = state.y
      ctx.beginPath();
      ctx.lineWidth = this._grid.scale(this.pen.weight())
      ctx.strokeStyle = this.pen.color()
      ctx.arc(this._grid.x(x), this._grid.y(y), this._grid.scale(radius), 0, 2 * Math.PI, true)
      ctx.stroke();
    }, this)
  }
  
  disc(radius) {
    return this._sequencer.run(function() {
      var state = this._state
        , ctx = this._drawContext
        , x = state.x
        , y = state.y
      ctx.beginPath();
      ctx.fillStyle = this.pen.color()
      ctx.arc(this._grid.x(x), this._grid.y(y), this._grid.scale(radius), 0, 2 * Math.PI, true)
      ctx.fill();
    }, this)
  }
  
  flood() {
    this._sequencer.run(function() {
      var ctx = this._drawContext
        , grid = this._grid
      ctx.fillStyle = this.pen.color()
      ctx.fillRect(0, 0, grid.width, grid.height)
      }, this)
  }

  xy(x, y) {
    if (arguments.length === 0) {
      return { x: this._state.x, y: this._state.y }
    } else {
      return this._sequencer.run(function() {
        this._line(x, y)
      }, this)
    }
  }
  
  x(x) {
    if (arguments.length === 0) {
      return this._state.x
    } else {
      return this._sequencer.run(function() {
        this._line(x, this._state.y)
      }, this)
    }
  }
  
  y(y) {
    if (arguments.length === 0) {
      return this._state.y
    } else {
      return this._sequencer.run(function() {
        this._line(this._state.x, y)
      }, this)
    }
  }

  rt(deg) {
    return this._sequencer.runNoDelay(function() {
      var state = this._state
        , oldHeading = state.heading
        , newHeading = oldHeading + deg
      while (newHeading < 0) {
        newHeading += 360
      }
      while (newHeading > 360) {
        newHeading -= 360
      }
      state.heading = newHeading
      this._locateCursor()
    }, this)
  }
  
  lt(deg) {
    return this.rt(-deg)
  }
  
  face(x, y) {
    return this._sequencer.runNoDelay(function() {
      var state = this._state
        , headingRad = Math.atan2(x - state.x, y - state.y)
      state.heading = headingRad * (180/Math.PI)
      this._locateCursor()
    }, this)
  }
  
  away(x, y) {
    return this._sequencer.runNoDelay(function() {
      var state = this._state
        , headingRad = Math.atan2(x - state.x, y - state.y) + Math.PI
      state.heading = headingRad * (180/Math.PI)
      this._locateCursor()
    }, this)
  }
  
  heading(deg) {
    if (arguments.length === 0) {
      return this._state.heading
    } else {
      return this._sequencer.runNoDelay(function() {
        this._state.heading = deg
        this._locateCursor()
      }, this)
    }
  }

  erase() {
    let seq = this._sequencer
      , ctx = this._drawContext
      , grid = this._grid
    seq.run(function() {
      ctx.clearRect(0, 0, grid.width, grid.height)
    }, this)
  }

  wait(time) {
    return this._sequencer.wait(time)
  }
}
