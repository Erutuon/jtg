/*
 * Copyright (c) 2015 by Greg Reimer <gregreimer@gmail.com>
 * All Rights Reserved.
 */

var co = require('co')
  , Promise = require('bluebird')
  , wait = require('jtg/wait')

/*
 * Run a bunch of things in asynchronous series. Running returns
 * a promise. If you run tasks synchronously or before the previous
 * promise resolves they'll queue up in memory, shifting out as they
 * run. If you add them after the previous promise resolves they
 * won't queue up in memory.
 */

module.exports = class {

  constructor() {
    this._commands = []
    this._running = false
  }

  runNoDelay(fn, ctx){
    var prom = new Promise()
    this._commands.push({
      fn: fn,
      context: ctx,
      promise: prom
    })
    this._start()
    return prom
  }

  run(fn, ctx){
    var prom = new Promise()
    this._commands.push({
      delay: 0,
      fn: fn,
      context: ctx,
      promise: prom
    })
    this._start()
    return prom
  }

  wait(time) {
    var prom = new Promise()
    this._commands.push({
      delay: time,
      promise: prom
    })
    this._start()
    return prom
  }

  _start() {
    if (!this._running) {
      this._running = true
      co(function*(){
        var cmds = this._commands
          , cmd
        while (cmd = cmds.shift()) {
          if (cmd.delay !== undefined) {
            yield wait(cmd.delay)
          }
          if (typeof cmd.fn === 'function') {
            cmd.fn.call(cmd.context)
          }
          cmd.promise.resolve()
        }
        this._running = false
      }, this)
    }
  }
}






