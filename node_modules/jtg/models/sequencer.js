/*
 * Copyright (c) 2015 by Greg Reimer <gregreimer@gmail.com>
 * All Rights Reserved.
 */

var co = require('co')
  , Promise = require('bluebird')
  , wait = require('jtg/wait')

/*
 * Run a bunch of things in asynchronous series. Running returns
 * a promise. If you run tasks synchronously or before the previous
 * promise resolves they'll queue up in memory, shifting out as they
 * run. If you add them after the previous promise resolves they
 * won't queue up in memory.
 */

module.exports = class {

  constructor() {
    this._commands = []
    this._running = Promise.resolve()
  }

  runNoDelay(fn, ctx){
    this._commands.push({
      fn: fn,
      context: ctx
    })
    return this._exec()
  }

  run(fn, ctx){
    this._commands.push({
      delay: 0,
      fn: fn,
      context: ctx
    })
    return this._exec()
  }

  wait(time) {
    this._commands.push({ delay: time })
    return this._exec()
  }

  _exec() {
    var commands = this._commands
    return this._running = this._running.then(function() {
      return co(function*() {
        while (commands.length > 0) {
          let command = commands.shift()
          if (command.delay !== undefined){
            yield wait(command.delay)
          }
          if (typeof command.fn === 'function') {
            command.fn.call(command.context)
          }
        }
      }).catch(function(err){
        console.error(err.stack)
      })
    })
  }
}
